# Robot

## 1 (drzewo przedziałowe)
???
## 2 (zachłanny)
chcemy dojść jak najdalej idąc prosto
przedziały
(coś tak jak napisałeś)


# Prezent
a gdyby mnożyć przez 2? zachłannie
wracając: w wyniku będzie podział na liczby ujemne (nieparzysta ilość 
operacji) i dodatnie (parzysta ilość operacji)
przemnożyć przez -2 na początku i mnożyć przez 4 później
suf[i] = wynik zachłannego algorytmu
min(pre[i] + suf[i]) dla 0\<i\<n

? ? ?
"zapas" na później


# Drift
"paski" po których można się poruszać = wierzchołek
połączenia = krawędzie

? ? ?
x1, x2, ... , xn (x = {0,1})
(x1 || x3) && (x2 || !x4) && ...

implikacja = krawędź w grafie

